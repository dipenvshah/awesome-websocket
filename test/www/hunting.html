<!DOCTYPE HTML>
<meta charset="UTF-8">

<html lang="en" ng-app='theApp'>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" href="//code.jquery.com/qunit/qunit-1.14.0.css">
  <title>reconnecting websocket tests</title>
  <script src="//code.jquery.com/qunit/qunit-1.14.0.js"></script>
  <script type="text/javascript">
    window.debug = true;
  </script>
  <script type="text/javascript" src="js/reconn.js"> </script>
  <script type="text/javascript" src="js/lodash.js"> </script>
  <script type="text/javascript">
    var Q = require('q');
    var ReconnectingWebSocket = require("reconnecting-websocket").ReconnectingWebSocket
    var controllingWs = new ReconnectingWebSocket("ws://localhost:8080/socket");
    controllingWs.gotPid = Q.defer();
    controllingWs.onmessage = function (evt) {
      var data = evt.data;
      try {
        data = JSON.parse(evt.data);
        if (data.pid){
          this.pid = data.pid;
        }
        this.gotPid.resolve();
      } catch (e) {
      }
    }.bind(controllingWs);
    controllingWs.onopen = function (evt) { controllingWs.send("what's your pid"); };

    QUnit.asyncTest('send prior to connect', function(assert) {
      var HuntingWebSocket = require("reconnecting-websocket").HuntingWebSocket;
      expect(5);
      var testWs = new HuntingWebSocket([
        "ws://localhost:8081/socket",
        "ws://localhost:8082/socket",
        "ws://localhost:8083/socket",
        "ws://localhost:8084/socket"
      ]);
      
      testWs.onconnectionopen = _.after(4, function() {
        assert.ok(true, "all connected");
        QUnit.start();
      });

      testWs.onopen = function(){
        assert.ok(true, "opened");
      };
      
      function validateMessageType(type, assertionMessage){
        function assertType (message){
          assert.equal(type, message.type, assertionMessage);
        }
        return _.once(assertType);
      }
      var onsenttoMessageTypeCheck = validateMessageType('onsentto', 'onsentto message type');
      testWs.onsentto = function(evt){
        onsenttoMessageTypeCheck(evt);
      }
      testWs.ondatanotsent = _.once(function(me){
        var data = JSON.parse(me.data);
        assert.equal(data.echoThis, "sent before sockets up", "datanotsent before sockets up");
      });
      testWs.onmessage = function(message){ 
        try{
          message = JSON.parse(message.data);
          if ( message.type === "echo" && message.echoThis === "sent before sockets up" ){
            assert.ok(true, "message sent before sockets were up, arrived");
          }
        } catch(e) {}
      }
      // this send will 'fail' until the servers start
      testWs.send('{"type": "echo", "echoThis": "sent before sockets up"}');
      controllingWs.gotPid.promise.then(function(){
        controllingWs.send(JSON.stringify({type: "start", port: 8081}));
        controllingWs.send(JSON.stringify({type: "start", port: 8082}));
        controllingWs.send(JSON.stringify({type: "start", port: 8083}));
        controllingWs.send(JSON.stringify({type: "start", port: 8084}));
      });

    });
    QUnit.asyncTest('message to dead server goes to next', function(assert) {
      var HuntingWebSocket = require("reconnecting-websocket").HuntingWebSocket;
      expect(1);
      var receivedEcho = Q.defer();
      var gotSecondMessage = Q.defer();
      var initialConnectionUsed;
      var secondConnectionUsed;
      var justDiedPort;
      var testWs = new HuntingWebSocket([
        "ws://localhost:8085/socket",
        "ws://localhost:8086/socket"
      ]);
      testWs.onmessage = function(evt){
        var message = JSON.parse(evt.data);
        // having received our first message our hunting socket will have set
        // it's currSocket to the connection used to send it
        if ( message.type === "echo" && message.echoThis === "first message" ){
          initialConnectionUsed = testWs.currSocket.underlyingWs.url;
          receivedEcho.resolve();
        } else if ( message.type === "echo" && message.echoThis === "second message" ){
          secondConnectionUsed = testWs.currSocket.underlyingWs.url;
          gotSecondMessage.resolve();
        } else if ( message.type === "dying" ){
          justDiedPort = message.port;
        }
      }
      testWs.onreconnect = function(){
        testWs.send(JSON.stringify({type: "echo", echoThis: "second message"}));
        console.log(testWs.currSocket.underlyingWs.url);
      }
      controllingWs.gotPid.promise.then(function(){
        controllingWs.send(JSON.stringify({type: "start", port: 8085}));
        controllingWs.send(JSON.stringify({type: "start", port: 8086}));
      });
      testWs.send(JSON.stringify({type: "echo", echoThis: "first message"}));
      receivedEcho.promise.then(function(){
        testWs.send("die");
        testWs.send(JSON.stringify({type: "echo", echoThis: "second message"}));
      });
      Q.all([receivedEcho.promise, gotSecondMessage.promise]).then(function(){
        console.log("pants");
        console.log(initialConnectionUsed);
        console.log(secondConnectionUsed);
        assert.notStrictEqual(initialConnectionUsed, secondConnectionUsed, "connections used");
        controllingWs.send(JSON.stringify({action: "kill", port: 8085}));
        controllingWs.send(JSON.stringify({action: "kill", port: 8086}));
        QUnit.start();
      });
    });

  </script>
</head>
<body>
  <div id="qunit"></div>
  <div id="qunit-fixture"></div>
</body>
</html>
